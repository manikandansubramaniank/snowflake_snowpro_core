# Transformations & Functions                                                                                                                                                                                               
What transformations are supported in a CREATE PIPE ... AS COPY `¦ FROM (`¦) statement? (Choose two.)                                                                                                                       
                                                                                                                                                                                                                            
A. Data can be filtered by an optional WHERE clause.<br>B. Incoming data can be joined with other tables.<br>C. Columns can be reordered.<br>D. Columns can be omitted.<br>E. Row level access can be defined.              
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>C, D</strong>                                                                                                                                                                                                       
                                                                                                                                                                                                                            
The correct answer is indeed C and D. Let's break down why these are supported transformations within a                                                                                                                     
CREATE PIPE ... AS COPY ... FROM statement in Snowflake, and why the other options are not.                                                                                                                                 
A CREATE PIPE statement in Snowflake is used to establish a pipeline that automatically loads data from a                                                                                                                   
cloud storage location (like AWS S3, Azure Blob Storage, or Google Cloud Storage) into a Snowflake table.                                                                                                                   
The core of this pipeline is the COPY command. Therefore, the transformations allowed in the CREATE PIPE                                                                                                                    
are essentially those supported directly by the COPY command.                                                                                                                                                               
Options C and D are correct because the COPY command allows you to reorder and omit columns during the                                                                                                                      
data loading process. You can specify a subset of columns from the source data file in the INTO <table> clause                                                                                                              
of the COPY command, effectively omitting columns that you don't need. Furthermore, you can specify the                                                                                                                     
order of these columns to match the table's column order, regardless of the order in the source file. This                                                                                                                  
provides flexibility in mapping source data to the destination table's schema.                                                                                                                                              
Option A is incorrect. While a WHERE clause can filter data in a general SQL query, it's not directly supported                                                                                                             
within the COPY command, and hence not available directly within the CREATE PIPE ... AS COPY statement.                                                                                                                     
Filtering generally requires additional processing steps after the data has been loaded, perhaps using a                                                                                                                    
separate SQL query or transformation.                                                                                                                                                                                       
Option B is incorrect. The COPY command focuses on loading data from an external source into a single table.Joining with other tables is not a function of the COPY command. Joins are operations performed on data after   
it has been loaded into Snowflake.                                                                                                                                                                                          
Option E is also incorrect. Row-level access policies are defined separately and do not form a part of the data                                                                                                             
loading process defined within the COPY command used by the pipe. Row-level access policies are                                                                                                                             
implemented through masking policies and row access policies, which are applied to tables after data has                                                                                                                    
been loaded. They govern which users can see which rows of data.                                                                                                                                                            
In summary, the COPY command within a CREATE PIPE statement provides simple transformation                                                                                                                                  
capabilities focused on mapping source data to the destination table, primarily through column selection                                                                                                                    
(omission) and reordering. More complex transformations require separate processing steps performed after                                                                                                                   
the data is loaded.                                                                                                                                                                                                         
For further reading, refer to the Snowflake documentation on the COPY command and CREATE PIPE:                                                                                                                              
COPY command: https://docs.snowflake.com/en/sql-reference/sql/copy-into-table.html                                                                                                                                          
CREATE PIPE: https://docs.snowflake.com/en/sql-reference/sql/create-pipe.html                                                                                                                                               
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which Snowflake function will interpret an input string as a JSON document, and produce a VARIANT value?                                                                                                                    
                                                                                                                                                                                                                            
A. parse_json()<br>B. json_extract_path_text()<br>C. object_construct()<br>D. flatten                                                                                                                                       
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>A</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is A. parse_json(). This function in Snowflake is specifically designed to interpret a string                                                                                                            
containing JSON data and transform it into a VARIANT data type. VARIANT is a semi-structured data type in                                                                                                                   
Snowflake that can store JSON, XML, and other similar types of data, allowing for flexible schema handling.                                                                                                                 
The parse_json() function effectively parses the provided JSON string, creating a hierarchical structure within                                                                                                             
the VARIANT, making it queryable. This process is vital for extracting and analyzing JSON data within the                                                                                                                   
Snowflake environment. Options B, json_extract_path_text(), extracts specific text values from a JSON                                                                                                                       
structure but does not convert the whole string into a VARIANT. Option C, object_construct(), creates a JSON                                                                                                                
object from key-value pairs, not by parsing a JSON string. Option D, flatten(), is used to transform array                                                                                                                  
elements into rows, useful for deconstructing array-like structures stored within a VARIANT, but does not                                                                                                                   
parse a JSON string into a VARIANT. Therefore, only parse_json() accurately addresses the prompt                                                                                                                            
requirement by turning a JSON formatted string into a VARIANT type. The resulting VARIANT is the base                                                                                                                       
object to perform further operations including flattening and extraction of key-value pairs.                                                                                                                                
Further reading:                                                                                                                                                                                                            
Snowflake Documentation - parse_json                                                                                                                                                                                        
Snowflake Documentation - Variant Data Type                                                                                                                                                                                 
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which constraint type is enforced in Snowflake from the ANSI SQL standard?                                                                                                                                                  
                                                                                                                                                                                                                            
A. UNIQUE<br>B. PRIMARY KEY<br>C. FOREIGN KEY<br>D. NOT NULL                                                                                                                                                                
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
Snowflake, while compliant with ANSI SQL standards in many areas, enforces only the NOT NULL constraint                                                                                                                     
type from the perspective of data integrity enforcement at the database level. UNIQUE and PRIMARY KEY                                                                                                                       
constraints are supported syntactically, meaning you can define them in your table schemas, but Snowflake                                                                                                                   
does not actively enforce them. This means you can insert duplicate values into a column declared as UNIQUE                                                                                                                 
or have rows where the PRIMARY KEY column contains a null value or a duplicate. FOREIGN KEY constraints                                                                                                                     
are not actively enforced either, allowing data inconsistencies where foreign key relationships would normally                                                                                                              
prevent insertion or deletion of rows based on relational integrity.                                                                                                                                                        
Snowflake's decision to only enforce NOT NULL is often tied to its focus on performance and scalability for                                                                                                                 
data warehousing and analytics. Enforcing UNIQUE, PRIMARY KEY, and FOREIGN KEY constraints typically                                                                                                                        
requires additional overhead in terms of indexing and real-time constraint checking during data loading and                                                                                                                 
modification. This can significantly impact write performance, especially when dealing with massive datasets,                                                                                                               
a common scenario in Snowflake environments. Instead, Snowflake encourages users to handle data integrity                                                                                                                   
through data transformation pipelines and validation processes that occur before the data is loaded into                                                                                                                    
Snowflake, or through post-load validation processes. These ETL/ELT processes are often more efficient and                                                                                                                  
customizable to the specific data quality needs of the organization. Therefore, the NOT NULL constraint is the                                                                                                              
only constraint that is inherently enforced at the database level within Snowflake. The others are more for                                                                                                                 
metadata purposes.                                                                                                                                                                                                          
Further Research:                                                                                                                                                                                                           
Snowflake Documentation on Constraints: https://docs.snowflake.com/en/sql-reference/constraints                                                                                                                             
Snowflake Community Forum discussion on Primary Keys: (Search on Snowflake community forum for                                                                                                                              
"Primary Key Enforcement") - While not a direct link, searching will provide multiple discussions on this topic                                                                                                             
illustrating that they are not enforced.                                                                                                                                                                                    
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
What Snowflake function should be used to unload relational data to JSON?                                                                                                                                                   
                                                                                                                                                                                                                            
A. BUILD_STAGE_FILE_URL()<br>B. OBJECT_CONSTRUCT()<br>C. PARSE_JSON()<br>D. TO_VARIANT()                                                                                                                                    
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>B</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is B. OBJECT_CONSTRUCT(). This function is specifically designed to construct a JSON                                                                                                                     
object from key-value pairs, which is essential when transforming relational data into JSON format.                                                                                                                         
Snowflake's OBJECT_CONSTRUCT() takes column names and their corresponding values from a relational                                                                                                                          
table as inputs and generates a JSON object where the column names act as keys and the values are                                                                                                                           
associated values.                                                                                                                                                                                                          
Let's explore why the other options are not suitable. BUILD_STAGE_FILE_URL() (A) generates a URL for                                                                                                                        
accessing files on a stage, which is relevant for file manipulation, not data transformation to JSON.                                                                                                                       
PARSE_JSON() (C) is used to convert a string containing JSON into a Snowflake variant data type; this                                                                                                                       
function is designed for loading JSON data, not for generating it. TO_VARIANT() (D) converts any data type to                                                                                                               
a Snowflake variant type, which can store JSON data; however, it doesn’t provide the means to transform                                                                                                                     
relational data to JSON structure specifically.                                                                                                                                                                             
When unloading relational data to JSON, we need a function that actively structures the data into a JSON                                                                                                                    
object. Therefore, OBJECT_CONSTRUCT() is the fundamental function to achieve this. It allows us to                                                                                                                          
explicitly define the JSON structure, ensuring that we get the expected JSON output. Other functions might                                                                                                                  
come into play if we have further processing required, but the core operation of transforming relational data                                                                                                               
to JSON format is handled by OBJECT_CONSTRUCT(). This function allows flexible construction, as the                                                                                                                         
values passed to the function could also be derived from expressions, not just literal column references,                                                                                                                   
enabling more complex transformations.                                                                                                                                                                                      
For further reading and verification, refer to the official Snowflake documentation on the                                                                                                                                  
OBJECT_CONSTRUCT() function: https://docs.snowflake.com/en/sql-reference/functions/object_construct.                                                                                                                        
You can also look into the data transformation guides for snowflake that demonstrates this concept.                                                                                                                         
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which data types in Snowflake are synonymous for FLOAT? (Choose two.)                                                                                                                                                       
                                                                                                                                                                                                                            
A. DECIMAL<br>B. DOUBLE<br>C. NUMBER<br>D. NUMERIC<br>E. REAL                                                                                                                                                               
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>B, E</strong>                                                                                                                                                                                                       
                                                                                                                                                                                                                            
The question asks for data types in Snowflake that are synonymous with FLOAT. In Snowflake, the FLOAT                                                                                                                       
data type represents a single-precision floating-point number, adhering to the IEEE 754 standard. This                                                                                                                      
standard defines how floating-point numbers are represented and handled in computer systems. DOUBLE is                                                                                                                      
also a floating-point type in Snowflake, representing a double-precision floating-point number, which offers a                                                                                                              
higher level of precision than FLOAT, but both are used to store numeric values with fractional parts.                                                                                                                      
Consequently, DOUBLE is considered synonymous with FLOAT within the broader category of representing                                                                                                                        
real numbers, and they may often be used interchangeably depending on precision requirements.                                                                                                                               
REAL in Snowflake is specifically defined as a synonym for FLOAT. This means that when a column is                                                                                                                          
declared as REAL, Snowflake internally treats it as a FLOAT type, thus the choice REAL is also correct.                                                                                                                     
Therefore, both DOUBLE and REAL are valid choices for the FLOAT datatype.                                                                                                                                                   
The other options are incorrect. DECIMAL, NUMBER, and NUMERIC are all synonymous with each other in                                                                                                                         
Snowflake and are used to represent fixed-point numbers. They store numeric values with a specific scale and                                                                                                                
precision, making them unsuitable for representing the varying precision of floating-point numbers which can                                                                                                                
lead to more approximate representations of numeric values as compared to the fixed-precision values in                                                                                                                     
these fixed-point datatypes. Fixed-point datatypes are ideal for monetary amounts or data needing precise                                                                                                                   
decimal accuracy, while FLOAT and DOUBLE are used in scientific computations where approximations are                                                                                                                       
acceptable and are more flexible when large or very small numbers are involved.                                                                                                                                             
In summary, Snowflake's documentation clarifies that REAL is an alias for FLOAT, and DOUBLE represents a                                                                                                                    
more precise version of floating point, making them synonymous in practical use scenarios that don't need to                                                                                                                
strictly adhere to single or double-precision floating points.                                                                                                                                                              
Authoritative links:                                                                                                                                                                                                        
Snowflake Data Types Documentation: https://docs.snowflake.com/en/sql-reference/data-types-numeric                                                                                                                          
IEEE 754 Standard: https://standards.ieee.org/ieee/754/6377/                                                                                                                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function can be combined with the copy command to unload a relational table into a JSON file?                                                                                                                         
                                                                                                                                                                                                                            
A. FLATTEN<br>B. LISTAGG<br>C. OBJECT_CONSTRUCT<br>D. PARSE_JSON                                                                                                                                                            
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>C</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is C. OBJECT_CONSTRUCT. Here's why:                                                                                                                                                                      
Snowflake's COPY command is primarily designed for loading and unloading data between Snowflake tables                                                                                                                      
and external stages (like S3 buckets). When unloading data into a file format, such as JSON, the data from                                                                                                                  
relational tables needs to be transformed into the structured JSON format. The OBJECT_CONSTRUCT                                                                                                                             
function is purpose-built for this. It allows you to construct a JSON object (represented as a VARIANT data                                                                                                                 
type in Snowflake) by specifying key-value pairs, where the values are often derived from columns in yourrelational table. This resulting JSON object can then be written to a single file or multiple files via the COPY   
command's FILE_FORMAT option and specifying TYPE=JSON.                                                                                                                                                                      
Option A, FLATTEN, is used for exploding array or object structures into rows. While it's useful for querying                                                                                                               
nested JSON data within Snowflake, it's not applicable to creating JSON during an unload operation. Option B,                                                                                                               
LISTAGG, is used for concatenating strings from multiple rows into a single string, often with a delimiter,                                                                                                                 
which is unsuitable for JSON file creation. Option D, PARSE_JSON, is for parsing a JSON string into a                                                                                                                       
VARIANT data type in Snowflake, not constructing JSON for export. Therefore, only OBJECT_CONSTRUCT is                                                                                                                       
the appropriate choice to transform relational data into JSON before using COPY for unloading.                                                                                                                              
To elaborate, the COPY INTO command, when used for unloading, extracts data from a Snowflake table and,                                                                                                                     
in conjunction with the FILE_FORMAT option, transforms that data into the specified format. When a JSON file                                                                                                                
format is targeted, the need for structured data within JSON dictates using OBJECT_CONSTRUCT to mold                                                                                                                        
data rows into JSON objects. Other functions don't address this specific transformation need effectively                                                                                                                    
within the COPY process. The COPY command's interaction with the specified file format is critical.                                                                                                                         
For further research, consult these official Snowflake documentation pages:                                                                                                                                                 
1. COPY command: https://docs.snowflake.com/en/sql-reference/sql/copy-into-location.html                                                                                                                                    
2. OBJECT_CONSTRUCT function: https://docs.snowflake.com/en/sqlreference/functions/object_construct.html                                                                                                                    
3. File Formats for Copy: https://docs.snowflake.com/en/sql-reference/sql/create-file-format.html                                                                                                                           
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which type of join will list all rows in the specified table, even if those rows have no match in the other table?                                                                                                          
                                                                                                                                                                                                                            
A. Cross join<br>B. Inner join<br>C. Natural join<br>D. Outer join                                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is D. Outer join. Here's why:Outer joins are specifically designed to include all rows from at least one of the participating tables in the                                                              
result set, even when no matching row exists in the other table based on the join condition. There are three                                                                                                                
types of outer joins: left, right, and full. A left outer join includes all rows from the left table; a right outer join                                                                                                    
includes all rows from the right table; and a full outer join includes all rows from both tables.                                                                                                                           
Inner joins, by contrast, only return rows where a match is found in both tables based on the join condition,                                                                                                               
effectively excluding any non-matching rows. A cross join creates a Cartesian product, combining every row                                                                                                                  
from the first table with every row from the second, which doesn't align with the requirement of including all                                                                                                              
rows from a specified table. Natural joins attempt to join based on columns with the same names; however,                                                                                                                   
they still function as an inner join unless explicitly specified as an outer join.                                                                                                                                          
Therefore, only an outer join can guarantee that all rows from a specified table are included, even if no match                                                                                                             
exists, fulfilling the requirement of the question. When a match isn't found in the other table during an outer                                                                                                             
join, the result set will fill the non-matching columns from the other table with NULL values. This behavior is                                                                                                             
fundamental to how outer joins handle cases with missing corresponding data.                                                                                                                                                
Here are some links for further learning:                                                                                                                                                                                   
Snowflake Documentation on Joins: https://docs.snowflake.com/en/sql-reference/queries-joins-overview                                                                                                                        
SQL Joins Visual Explanation: https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQLJoins                                                                                                                  
Khan Academy SQL Joins: https://www.khanacademy.org/computing/computer-programming/sql/sql-tablerelations/a/sql-joins                                                                                                       
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
What is the purpose of the Snowflake SPLIT_TO_TABLE function?                                                                                                                                                               
                                                                                                                                                                                                                            
A. To count the number of characters in a string<br>B. To split a string into an array of sub-strings<br>C. To split a string and flatten the results into rows<br>D. To split a string and flatten the results into columns
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>C</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is C. To split a string and flatten the results into rows. The SPLIT_TO_TABLE function in                                                                                                                
Snowflake is designed specifically for transforming delimited strings into a tabular format, where each                                                                                                                     
substring becomes a row. This is particularly useful when dealing with data that stores multiple values within                                                                                                              
a single string, separated by a delimiter (like a comma, semicolon, or any other character).                                                                                                                                
Unlike simple string splitting functions that might return an array or list of substrings, SPLIT_TO_TABLE                                                                                                                   
flattens these substrings into individual rows within a result set. This output is highly compatible withstandard SQL queries and allows you to work directly with each individual value as a distinct row in a table.      
This function excels in situations involving denormalized data, where data is stored in a combined, delimited                                                                                                               
format and needs to be broken apart for analysis or further processing.                                                                                                                                                     
Options A, B, and D are incorrect. Option A, counting characters, is the function of other string functions, such                                                                                                           
as LENGTH. Option B, splitting a string into an array, is not the purpose of SPLIT_TO_TABLE, although other                                                                                                                 
functions like SPLIT might produce an array. Option D, splitting into columns, is not directly supported by                                                                                                                 
SPLIT_TO_TABLE, which focuses solely on flattening data into rows. The power of SPLIT_TO_TABLE lies in                                                                                                                      
transforming semi-structured data into a structured, relational format within Snowflake. This promotes more                                                                                                                 
efficient data handling and simplifies complex queries involving this denormalized data.                                                                                                                                    
For further research, consult Snowflake's official documentation on string functions, specifically the details                                                                                                              
for SPLIT_TO_TABLE:https://docs.snowflake.com/en/sql-reference/functions/split_to_table.html                                                                                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function determines the kind of value stored in a VARIANT column?                                                                                                                                                     
                                                                                                                                                                                                                            
A. CHECK_JSON<br>B. IS_ARRAY<br>C. IS_JSON<br>D. TYPEOF                                                                                                                                                                     
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is D. TYPEOF. The TYPEOF function in Snowflake is specifically designed to                                                                                                                               
identify the data type of a value stored within a VARIANT column. VARIANT columns, being semistructured, can hold various data types such as strings, numbers, booleans, arrays, and objects.                               
TYPEOF allows you to dynamically determine what kind of data you're currently working with in                                                                                                                               
that column, crucial for writing conditional logic and data processing pipelines that handle diverse                                                                                                                        
data types.                                                                                                                                                                                                                 
Options A, B, and C are not valid Snowflake functions for determining a VARIANT's underlying                                                                                                                                
data type. CHECK_JSONB.IS_ARRAY (A) is not a valid Snowflake function. IS_JSON (C) might                                                                                                                                    
seem relevant, but it only checks if a string is valid JSON, not the type of content inside a                                                                                                                               
VARIANT. TYPEOF, on the other hand, accurately reflects whether a VARIANT holds a string,                                                                                                                                   
number, boolean, array, or object. Understanding the data type within a VARIANT is essential for                                                                                                                            
many SQL operations, such as filtering data based on type-specific logic or converting values                                                                                                                               
between different types.                                                                                                                                                                                                    
This function proves especially beneficial when dealing with external data sources, which often                                                                                                                             
load data in JSON format where fields can have diverse structures and types. The TYPEOF                                                                                                                                     
function facilitates the development of robust, flexible data pipelines by enabling runtime checks.                                                                                                                         
In essence, TYPEOF helps to navigate the flexibility of semi-structured data, making the queryand transformation process more effective.                                                                                    
Further research can be done at Snowflake's official documentation. The following link provides                                                                                                                             
detailed information regarding TYPEOF and its use with VARIANT data:                                                                                                                                                        
https://docs.snowflake.com/en/sql-reference/functions/typeof                                                                                                                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
What type of function returns one value for each invocation?                                                                                                                                                                
                                                                                                                                                                                                                            
A. Aggregate<br>B. Scalar<br>C. Table<br>D. Window                                                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>B</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is B, Scalar functions. Scalar functions are designed to operate on individual                                                                                                                           
input values and return a single output value for each invocation. They are deterministic, meaning                                                                                                                          
the same input will always yield the same output. In Snowflake, common examples include                                                                                                                                     
mathematical operations (like ABS, ROUND), string manipulations (SUBSTR, UPPER), and                                                                                                                                        
date/time functions (CURRENT_DATE, MONTH). These functions transform or analyze a single                                                                                                                                    
piece of data, always producing a corresponding single result. Aggregate functions (A) operate on                                                                                                                           
groups of rows and return a single summarized result per group (e.g., COUNT, SUM, AVG). Table                                                                                                                               
functions (C) return a table as output, not a single value. Window functions (D) also operate on a                                                                                                                          
set of rows, called a window, but return a single value for each row within the window based on                                                                                                                             
that row’s position within the defined partition; they do not return one value per function                                                                                                                                 
invocation across a table, but a value based on a "window" over rows. Therefore, only scalar                                                                                                                                
functions are specifically designed to return one output value per invocation.                                                                                                                                              
Here are some helpful resources for further research:                                                                                                                                                                       
Snowflake Documentation on Scalar Functions: https://docs.snowflake.com/en/sqlreference/functions-scalar.html                                                                                                               
Snowflake Documentation on Aggregate Functions: https://docs.snowflake.com/en/sqlreference/functions-aggregate.html                                                                                                         
Snowflake Documentation on Table Functions: https://docs.snowflake.com/en/sqlreference/functions-table.html                                                                                                                 
Snowflake Documentation on Window Functions: https://docs.snowflake.com/en/sqlreference/functions-window.html                                                                                                               
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function is used to convert rows in a relational table to a single VARIANT column?                                                                                                                                    
                                                                                                                                                                                                                            
A. ARRAY_AGG<br>B. OBJECT_AGG<br>C. ARRAY_CONSTRUCT<br>D. OBJECT_CONSTRUCT                                                                                                                                                  
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is D. OBJECT_CONSTRUCT. The objective is to consolidate multiple relational                                                                                                                              
table rows into a single VARIANT column, which is a semi-structured data type in Snowflake                                                                                                                                  
capable of storing JSON-like data. OBJECT_CONSTRUCT is designed specifically for this                                                                                                                                       
purpose. It takes key-value pairs as input and constructs a JSON object, which is then stored as a                                                                                                                          
VARIANT. Each row's data is transformed into a JSON object where column names become keys                                                                                                                                   
and the corresponding row values become the values. This object is then placed within the                                                                                                                                   
designated VARIANT column for each row.                                                                                                                                                                                     
ARRAY_AGG (option A), on the other hand, aggregates values from different rows into a single                                                                                                                                
array within a single row, not across multiple rows into a single VARIANT column. OBJECT_AGG                                                                                                                                
(option B) is similar to ARRAY_AGG in function and not relevant to the goal of transforming entire                                                                                                                          
rows. ARRAY_CONSTRUCT (option C) creates a VARIANT array, not a VARIANT object, and                                                                                                                                         
doesn't transform rows into a single, cohesive, column. Therefore, OBJECT_CONSTRUCT is the                                                                                                                                  
only appropriate function that satisfies the requirement of converting relational rows to a single                                                                                                                          
VARIANT column, as it explicitly generates JSON-like objects suitable for storage in a VARIANT                                                                                                                              
column, which is Snowflake’s primary method for handling semi-structured data.                                                                                                                                              
Further Research:                                                                                                                                                                                                           
Snowflake Documentation on OBJECT_CONSTRUCT: https://docs.snowflake.com/en/sqlreference/functions/object_construct                                                                                                          
Snowflake Documentation on VARIANT Data Type: https://docs.snowflake.com/en/sqlreference/data-types-semistructured                                                                                                          
Snowflake Documentation on ARRAY_AGG: https://docs.snowflake.com/en/sqlreference/functions/array_agg                                                                                                                        
Snowflake Documentation on OBJECT_AGG: https://docs.snowflake.com/en/sqlreference/functions/object_agg                                                                                                                      
Snowflake Documentation on ARRAY_CONSTRUCT: https://docs.snowflake.com/en/sqlreference/functions/array_construct                                                                                                            
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which command should be used to look into the validity of an XML object in Snowflake?                                                                                                                                       
                                                                                                                                                                                                                            
A. XMLGET<br>B. TO_XML<br>C. PARSE_XML<br>D. CHECK_XML                                                                                                                                                                      
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct command for validating an XML object within Snowflake is PARSE_XML.                                                                                                                                             
Options A (XMLGET) and B (TO_XML) are used for extracting elements from and                                                                                                                                                 
converting data to XML formats respectively, not for validation. Option D (CHECK_XML)                                                                                                                                       
is a made-up command and doesn't exist in Snowflake's SQL syntax. PARSE_XML is                                                                                                                                              
designed to process XML strings and attempts to parse the provided input as XML. If the                                                                                                                                     
provided XML is invalid according to XML syntax rules, PARSE_XML will return a NULL                                                                                                                                         
value or raise an error depending on the function's use. This implicit validation is crucial                                                                                                                                
for ensuring data integrity and usability within Snowflake's structured data                                                                                                                                                
environment. In essence, the act of parsing is what checks for validity. The function                                                                                                                                       
ensures the XML is well-formed and can be processed. Because it's built into the                                                                                                                                            
function itself, the parsing process implicitly validates the XML object's structure.                                                                                                                                       
Authoritative links for further research:                                                                                                                                                                                   
1. Snowflake Documentation on PARSE_XML: https://docs.snowflake.com/en/sqlreference/functions/parse_xml                                                                                                                     
2. Snowflake Documentation on XML Functions:                                                                                                                                                                                
https://docs.snowflake.com/en/sql-reference/functions-xml                                                                                                                                                                   
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function returns an integer between 0 and 100 when used to calculate the similarity of two strings?                                                                                                                   
                                                                                                                                                                                                                            
A. APPROXIMATE_SIMILARITY<br>B. JAROWINKLER_SIMILARITY<br>C. APPROXIMATE_JACCARD_INDEX<br>D. MINHASH_COMBINE                                                                                                                
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>B</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is B. JAROWINKLER_SIMILARITY. The JAROWINKLER_SIMILARITY                                                                                                                                                 
function, within Snowflake's string manipulation capabilities, computes a similarity                                                                                                                                        
score between two input strings. This score is specifically designed to return a value                                                                                                                                      
within the range of 0 to 1, representing the level of similarity, where 0 signifies no                                                                                                                                      
similarity and 1 indicates an exact match. This output is then often converted into a                                                                                                                                       
percentage by multiplying by 100 to express it as a value between 0 and 100. The                                                                                                                                            
function prioritizes matching characters that are closer together within the strings,                                                                                                                                       
which makes it effective for detecting minor typographical or transpositional errors.                                                                                                                                       
In contrast, APPROXIMATE_SIMILARITY does not consistently produce a value between                                                                                                                                           
0 and 100 and the function's behaviour is often dependent on the input strings. Similarly,                                                                                                                                  
APPROXIMATE_JACCARD_INDEX, while measuring the overlap between sets                                                                                                                                                         
represented by the strings, typically outputs a score within the range of 0 to 1.                                                                                                                                           
MINHASH_COMBINE, which computes the minhash of a column, is also not related to                                                                                                                                             
string similarity in a manner that directly yields a 0-100 range. Therefore, out of these                                                                                                                                   
options, JAROWINKLER_SIMILARITY is the only function that directly and consistently                                                                                                                                         
produces values that can be scaled to a 0-100 range to represent string similarity.                                                                                                                                         
For further research, the Snowflake documentation provides detailed information about                                                                                                                                       
string functions and their usage. Specifically, the documentation for                                                                                                                                                       
JAROWINKLER_SIMILARITY would validate its output range and function.                                                                                                                                                        
Authoritative Link:                                                                                                                                                                                                         
Snowflake Documentation on String Functions: https://docs.snowflake.com/en/sqlreference/functions-string.html (Search for JAROWINKLER_SIMILARITY on this page).                                                             
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function can be used with the COPY INTO statement to convert rows from a relational table to a single                                                                                                                 
VARIANT column, and to unload rows into a JSON file?                                                                                                                                                                        
                                                                                                                                                                                                                            
A. FLATTEN<br>B. OBJECT_AS<br>C. OBJECT_CONSTRUCT<br>D. TO_VARIANT                                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>C</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is C. OBJECT_CONSTRUCT.                                                                                                                                                                                  
Here's why:                                                                                                                                                                                                                 
The OBJECT_CONSTRUCT function in Snowflake is explicitly designed to create a                                                                                                                                               
VARIANT object (which is Snowflake's semi-structured data type) from key-value pairs                                                                                                                                        
derived from relational table columns. When used within a COPY INTO statement, it                                                                                                                                           
transforms each row of the table into a JSON object representation, allowing you to                                                                                                                                         
effectively store the row as a single VARIANT column or unload the table's data into                                                                                                                                        
JSON files.                                                                                                                                                                                                                 
Option A, FLATTEN, is designed to "unpivot" data within a VARIANT, not create it. It                                                                                                                                        
expands array or object data into individual rows. Option B, OBJECT_AS, is not a valid                                                                                                                                      
Snowflake function. Option D, TO_VARIANT, converts a single value into a VARIANT data                                                                                                                                       
type but does not perform the row-to-object transformation like OBJECT_CONSTRUCT.                                                                                                                                           
For example, if a table has columns id, name, and age, the OBJECT_CONSTRUCT( 'id', id,                                                                                                                                      
'name', name, 'age', age) function would create a JSON object like "id": 1, "name": "John                                                                                                                                   
Doe", "age": 30 for each row, making it ideal for exporting relational data as JSON. This                                                                                                                                   
is precisely the functionality required for loading data into a single VARIANT column                                                                                                                                       
within Snowflake, or when unloading to JSON formatted files. The COPY INTO statement                                                                                                                                        
uses this function within its select expression to perform the transformation before                                                                                                                                        
export.                                                                                                                                                                                                                     
For further details, refer to Snowflake's official documentation:                                                                                                                                                           
OBJECT_CONSTRUCT: https://docs.snowflake.com/en/sqlreference/functions/object_construct.html                                                                                                                                
COPY INTO Statement: https://docs.snowflake.com/en/sql-reference/sql/copy-intotable.html                                                                                                                                    
Working with Semi-structured Data:                                                                                                                                                                                          
https://docs.snowflake.com/en/guides/semistructured-data.html                                                                                                                                                               
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which Snowflake function will parse a JSON-null into a SQL-null?                                                                                                                                                            
                                                                                                                                                                                                                            
A. TO_CHAR<br>B. TO_VARIANT<br>C. TO_VARCHAR<br>D. STRIP_NULL_VALUE                                                                                                                                                         
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is D. STRIP_NULL_VALUE. This function is specifically designed to                                                                                                                                        
convert JSON null values into SQL null values within Snowflake. When working with                                                                                                                                           
semi-structured data like JSON, it's common to encounter null representations that are                                                                                                                                      
distinct from SQL NULL. Snowflake stores JSON null values as literal string "null".                                                                                                                                         
Functions like TO_VARIANT, while able to ingest the JSON data, do not automatically                                                                                                                                         
convert "null" to a SQL NULL. Similarly, TO_CHAR and TO_VARCHAR are primarily used                                                                                                                                          
for data type conversion to strings and wouldn't handle this null conversion.                                                                                                                                               
STRIP_NULL_VALUE explicitly addresses this, inspecting variant data and replacing                                                                                                                                           
JSON "null" values with actual SQL NULLs. This is crucial for performing correct SQL                                                                                                                                        
operations and comparisons on the parsed JSON data. Without STRIP_NULL_VALUE,                                                                                                                                               
attempting arithmetic or logical comparisons on these JSON-null represented string                                                                                                                                          
would lead to unexpected results, as they are treated as strings not as SQL null. This                                                                                                                                      
function ensures data consistency between semi-structured and structured data in                                                                                                                                            
Snowflake. The function simplifies querying and analysis with JSON data. Using                                                                                                                                              
STRIP_NULL_VALUE is essential for robust data processing workflows.                                                                                                                                                         
Here are some authoritative links for further research:                                                                                                                                                                     
Snowflake Documentation on STRIP_NULL_VALUE: https://docs.snowflake.com/en/sqlreference/functions/strip_null_value.html                                                                                                     
Snowflake Documentation on Working with JSON:                                                                                                                                                                               
https://docs.snowflake.com/en/guides/semistructured-data/working-with-json.html                                                                                                                                             
Snowflake Blog on Semi-Structured Data: [Search Snowflake Blog for "Semi-Structured                                                                                                                                         
Data"](Search the Snowflake blog site for relevant content).                                                                                                                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which function unloads data from a relational table to JSON?                                                                                                                                                                
                                                                                                                                                                                                                            
A. TO_OBJECT<br>B. TO_JSON<br>C. TO_VARIANT<br>D. OBJECT_CONSTRUCT                                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The question asks which Snowflake function transforms relational table data into JSON                                                                                                                                       
format for unloading. While several functions deal with data transformation, only                                                                                                                                           
OBJECT_CONSTRUCT directly builds a JSON structure suitable for this purpose.                                                                                                                                                
TO_OBJECT attempts to convert an entire row into an object, not individual fields which                                                                                                                                     
often require customization for json, and doesn't allow for flexible json keys, TO_JSON                                                                                                                                     
isn't an actual function in Snowflake and TO_VARIANT converts to a Snowflake                                                                                                                                                
VARIANT datatype, which is similar to json but is not json. OBJECT_CONSTRUCT lets                                                                                                                                           
users specify the structure of the JSON document, mapping columns to named keys in                                                                                                                                          
the output. Therefore, OBJECT_CONSTRUCT is specifically designed to create JSON                                                                                                                                             
objects from relational data, making it the appropriate choice for preparing data for                                                                                                                                       
unloading as JSON. The other options either convert entire rows or to a format that's not                                                                                                                                   
json, and don't give the flexibility of specific json key names. When unloading data, users                                                                                                                                 
want control over the JSON's structure for downstream consumption, which                                                                                                                                                    
OBJECT_CONSTRUCT provides directly, whereas the others require additional                                                                                                                                                   
processing. Therefore, using OBJECT_CONSTRUCT is critical for this scenario.                                                                                                                                                
Here is the Snowflake documentation for OBJECT_CONSTRUCT for more information:                                                                                                                                              
https://docs.snowflake.com/en/sql-reference/functions/object_construct                                                                                                                                                      
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
What function, combined with the copy command, should be used to unload data from a relational table into a                                                                                                                 
JSON file?                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
A. LATERAL<br>B. CAST<br>C. FLATTEN<br>D. OBJECT_CONSTRUCT                                                                                                                                                                  
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct function to use with the COPY INTO command for unloading relational data                                                                                                                                        
into a JSON file in Snowflake is OBJECT_CONSTRUCT. Here's why:                                                                                                                                                              
Snowflake's COPY INTO command is designed to move data between tables and                                                                                                                                                   
external stages (like cloud storage). When unloading to a JSON file, the command                                                                                                                                            
doesn't inherently know how to represent the relational table data (columns and rows) as                                                                                                                                    
a structured JSON document. That's where OBJECT_CONSTRUCT comes in.OBJECT_CONSTRUCT is a function that creates a JSON object from key-value pairs. We                                                                       
use it within the COPY INTO statement's SELECT clause. Each table column becomes a                                                                                                                                          
JSON object key, and the corresponding column values become the values. This                                                                                                                                                
transform relational data into a format suitable for JSON.                                                                                                                                                                  
LATERAL is primarily used for expanding array or object structures. CAST changes data                                                                                                                                       
types, not structures, and FLATTEN expands arrays and objects, not the other way                                                                                                                                            
around. Therefore, these are not applicable to converting tabular to json format in this                                                                                                                                    
scenario.                                                                                                                                                                                                                   
The combination of OBJECT_CONSTRUCT within COPY INTO allows for granular control                                                                                                                                            
over the JSON output structure. You can choose which columns to include and rename                                                                                                                                          
them. It bridges the gap between relational data representation and a hierarchical JSON                                                                                                                                     
document. Ultimately, this lets you efficiently move data from Snowflake tables to                                                                                                                                          
external JSON files for various use cases like API data transfer or data lake ingestion.                                                                                                                                    
For further research:                                                                                                                                                                                                       
Snowflake Documentation on COPY INTO: https://docs.snowflake.com/en/sqlreference/sql/copy-into-location.html                                                                                                                
Snowflake Documentation on OBJECT_CONSTRUCT:                                                                                                                                                                                
https://docs.snowflake.com/en/sql-reference/functions/object_construct.html                                                                                                                                                 
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Use of which Snowflake function is recommended when unloading data from a relational table into a JSON file?                                                                                                                
                                                                                                                                                                                                                            
A. TO_JSON<br>B. TO_VARIANT<br>C. OBJECT_INSERT<br>D. OBJECT_CONSTRUCT                                                                                                                                                      
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is D. OBJECT_CONSTRUCT. When unloading data from a relational                                                                                                                                            
table into a JSON file in Snowflake, the primary goal is to structure the relational data                                                                                                                                   
into a valid JSON format. While TO_JSON or TO_VARIANT might seem applicable, they                                                                                                                                           
primarily deal with transforming individual data values into JSON-like strings, rather                                                                                                                                      
than creating structured JSON objects. OBJECT_INSERT is used to add key-value pairs                                                                                                                                         
to an existing JSON object, but doesn't create the initial object structure itself.                                                                                                                                         
OBJECT_CONSTRUCT is the function specifically designed to create a JSON object from                                                                                                                                         
named key-value pairs, directly mapping relational columns to JSON fields. This enables                                                                                                                                     
building a proper JSON structure where the relational data elements are represented asfields within the JSON file. By using OBJECT_CONSTRUCT, you specify the keys                                                          
representing your desired JSON fields and the corresponding values from the relational                                                                                                                                      
table. This function is crucial for controlling the final structure of the exported JSON,                                                                                                                                   
ensuring a well-formed output suitable for consumption by downstream applications                                                                                                                                           
that expect JSON format.                                                                                                                                                                                                    
For further details and examples, consult the official Snowflake documentation:                                                                                                                                             
https://docs.snowflake.com/en/sqlreference/functions/object_construct.htmlhttps://docs.snowflake.com/en/sqlreference/data-types-json.html                                                                                   
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which data type can be used for floating-point numbers without losing precision?                                                                                                                                            
                                                                                                                                                                                                                            
A. BINARY<br>B. VARIANT<br>C. INTEGER<br>D. DOUBLE                                                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The question asks about the appropriate data type in Snowflake for representing                                                                                                                                             
floating-point numbers without losing precision. The correct answer is D, DOUBLE.                                                                                                                                           
Here's why: Floating-point numbers, like 3.14159, are represented in computers using a                                                                                                                                      
specific format, often IEEE 754. This format inherently involves approximations due to                                                                                                                                      
finite bit representations. Single-precision floating-point numbers (often called "float"                                                                                                                                   
or "real") and double-precision floating-point numbers (often called "double") are                                                                                                                                          
common representations. DOUBLE offers higher precision than a simple FLOAT because                                                                                                                                          
it uses more bits for storage.                                                                                                                                                                                              
In Snowflake, the DOUBLE data type is designed for storing double-precision floatingpoint numbers, offering the greatest accuracy among built-in numeric types when                                                         
dealing with decimals. It attempts to minimize the inevitable loss of precision that occurs                                                                                                                                 
when dealing with floating-point data. INTEGER types, on the other hand, are for storing                                                                                                                                    
whole numbers and cannot accurately store fractional values. BINARY types are                                                                                                                                               
designed for storing raw binary data and are not suitable for numerical values. VARIANT,                                                                                                                                    
although flexible for handling diverse data, does not offer a specific precision guarantee,                                                                                                                                 
as it is a semi-structured data type that can store almost any type of information. Using                                                                                                                                   
VARIANT could introduce further complexities or lose precision during conversions if not                                                                                                                                    
handled carefully. Therefore, if you need to store floating point numbers with as much                                                                                                                                      
precision as possible, you should chose DOUBLE over the other options.                                                                                                                                                      
For further research, you can refer to the official Snowflake                                                                                                                                                               
documentation:https://docs.snowflake.com/en/sql-reference/data-typesnumeric.html#doublehttps://docs.snowflake.com/en/sql-reference/datatypes.htmlThese links provide a detailed overview of data types available within     
Snowflake and specifics regarding the DOUBLE type and its intended use case.                                                                                                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
In a SPLIT_PART function, what will the returned value be if the partNumber is out of range?                                                                                                                                
                                                                                                                                                                                                                            
A. −1<br>B. An empty string<br>C. The full string<br>D. An error                                                                                                                                                            
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>B</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The correct answer is B: An empty string.                                                                                                                                                                                   
The SPLIT_PART function in Snowflake is designed to extract a specific part of a string                                                                                                                                     
after it has been split based on a delimiter. Its syntax generally follows this pattern:                                                                                                                                    
SPLIT_PART(string, delimiter, partNumber). The partNumber argument specifies which                                                                                                                                          
part of the split string you want to retrieve.If the partNumber provided exceeds the number of parts generated by the splitting                                                                                             
operation, Snowflake doesn't throw an error. Instead, it gracefully handles this out-ofrange request by returning an empty string. This behavior is consistent with other string                                            
manipulation functions in Snowflake, which aim to avoid abrupt failures and provide                                                                                                                                         
predictable outcomes even when input data might not perfectly match expectations.                                                                                                                                           
Option A, returning -1, is incorrect because SPLIT_PART deals with strings, not                                                                                                                                             
numerical values, and there's no inherent concept of returning a negative index. Option                                                                                                                                     
C, returning the full string, is also incorrect because the purpose of SPLIT_PART is to                                                                                                                                     
return a specific part of the string, not the entire string itself. Option D, generating an                                                                                                                                 
error, is incorrect because Snowflake is designed to handle out-of-range indices                                                                                                                                            
gracefully with an empty string. The choice of an empty string allows further processing                                                                                                                                    
without halting execution or needing exception handling specifically for this function.                                                                                                                                     
The consistent handling of edge cases promotes robust and reliable data                                                                                                                                                     
transformations within the Snowflake environment. This behavior can be crucial in                                                                                                                                           
scenarios where data quality is variable and predictable error handling is necessary.                                                                                                                                       
For further research and authoritative documentation, you can refer to the Snowflake                                                                                                                                        
documentation on string functions: https://docs.snowflake.com/en/sqlreference/functions-string.html. While the specific behavior of SPLIT_PART regarding                                                                    
out-of-range partNumber might not be explicitly detailed in a dedicated section,                                                                                                                                            
examples and general descriptions of string functions demonstrate Snowflake's                                                                                                                                               
approach to error handling in these functions. Also, try executing a query with out-ofrange parameters in a Snowflake environment to prove this practically.                                                                
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which strings will be converted to TRUE using the TO_BOOLEAN() or CAST() functions when unloading data?                                                                                                                     
(Choose two.)                                                                                                                                                                                                               
                                                                                                                                                                                                                            
A. 0<br>B. n<br>C. no<br>D. on<br>E. yes                                                                                                                                                                                    
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D, E</strong>                                                                                                                                                                                                       
                                                                                                                                                                                                                            
The Correct answer is ["D","E"]                                                                                                                                                                                             
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which functions can be used to identify the data type stored in a VARIANT column? (Choose two.)                                                                                                                             
                                                                                                                                                                                                                            
A. IS_NULL_VALUE<br>B. IS_DATE_VALUE<br>C. IS_GEOGRAPHY<br>D. IS_XML<br>E. IS_JSON                                                                                                                                          
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>A, B</strong>                                                                                                                                                                                                       
                                                                                                                                                                                                                            
The Correct answer is ["A","B"]                                                                                                                                                                                             
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
How should the SPLIT_TO_TABLE([string], [delimiter]) function be called?                                                                                                                                                    
                                                                                                                                                                                                                            
A. SELECT SPLIT_TO_TABLE(COL1, '.') FROM DUAL;<br>B. SELECT SPLIT_TO_TABLE('a.b.c', '.');<br>C. SELECT * FROM TABLE(SPLIT_TO_TABLE('a.b.c', '.'));<br>D. SELECT * FROM SPLIT_TO_TABLE('a.b.c', '.');                        
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>C</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The Correct answer is ["C"]                                                                                                                                                                                                 
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which configuration of the function PARSE_JSON( ) will retrieve a valid SQL NULL value?                                                                                                                                     
                                                                                                                                                                                                                            
A. SELECT parse_json(NULL)<br>B. SELECT parse_json('null')<br>C. SELECT parse_json('[ null ]')<br>D. SELECT parse_json(' "a": null '):a                                                                                     
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>A</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The Correct answer is ["A"]                                                                                                                                                                                                 
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
---                                                                                                                                                                                                                         
Which clause is used to define a function that may return different values for different rows?                                                                                                                              
                                                                                                                                                                                                                            
A. IMMUTABLE<br>B. RETURNS<br>C. COMMENT<br>D. VOLATILE                                                                                                                                                                     
                                                                                                                                                                                                                            
<details>                                                                                                                                                                                                                   
<summary><strong>✅ Answer : </strong></summary>                                                                                                                                                                            
<strong>D</strong>                                                                                                                                                                                                          
                                                                                                                                                                                                                            
The Correct answer is ["D"]                                                                                                                                                                                                 
</details>                                                                                                                                                                                                                  
                                                                                                                                                                                                                            
                                                                                                                                                                                                                            
